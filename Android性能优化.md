#渲染
1.Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染， 如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意
味着程序的大多数操作都必须在16ms内完成。如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象
。那么用户在32ms内看到的会是同一帧画面。用户容易在UI执行动画或者滑动ListView的时候感知到卡顿不流畅，是因为这里的操作相对复杂，容易发生丢
帧的现象，从而感觉卡顿。
丢帧的原因：
--> layout太过复杂，无法在16S内完成渲染
--> UI 上层叠太多绘制单元
--> 动画执行的次数过多

问题定位:
HierarchyViewer查看界面布局是否太过复杂，或者在开发者选项里，打开Show GPU Overdraw等选项进行观察。还可以用traceview来观察GPU的执行情况，
更加快捷找到性能瓶颈


#GC
1.Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。
问题定位：Memory Monitor里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。
          还可以通过Allocation Tracker来查看在短时间内，同一个栈中不断进出的相同对象。
          
如何避免：
--> 不要在for循环中分配对象占用内存
--> 自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，不要在ondraw 方法里进行复杂的操作，
避免创建对象，对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用
之后，需要手动释放对象池中的对象
2. 内存泄露
内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。

#电量优化
